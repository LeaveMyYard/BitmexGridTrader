<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>sourse.exchange_handlers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sourse.exchange_handlers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import abc
import base64
import hashlib
import hmac
import json
import threading
import time
import typing
import urllib
from dataclasses import dataclass
from datetime import datetime

import bitmex
import websocket

from .logger import init_logger


class AbstractExchangeHandler(metaclass=abc.ABCMeta):
    def __init__(self, public_key: str, private_key: str):
        self._public_key = public_key
        self._private_key = private_key

    @dataclass
    class KlineCallback:
        time: datetime
        open: float
        high: float
        low: float
        close: float
        volume: float
        message: typing.Any

    @abc.abstractmethod
    def start_kline_socket(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.KlineCallback], None],
        candle_type: str,
        pair_name: str,
    ) -&gt; None:
        ...

    @dataclass
    class PriceCallback:
        price: float

    @abc.abstractmethod
    def start_price_socket(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.PriceCallback], None],
        pair_name: str
    ) -&gt; None:
        ...

    @dataclass
    class OrderUpdate:
        orderID: str
        client_orderID: str
        status: str
        price: float
        average_price: float
        fee: float
        fee_asset: str
        volume: float
        volume_realized: float
        time: datetime
        message: typing.Any

    UserUpdate = typing.Union[OrderUpdate]

    @abc.abstractmethod
    def start_user_update_socket(
        self, on_update: typing.Callable[[AbstractExchangeHandler.UserUpdate], None]
    ) -&gt; None:
        ...

    def start_kline_socket_threaded(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.KlineCallback], None],
        candle_type: str,
        pair_name: str,
    ) -&gt; threading.Thread:
        thread = threading.Thread(
            target=self.start_kline_socket, args=[on_update, candle_type, pair_name]
        )
        thread.start()
        return thread

    def start_price_socket_threaded(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.PriceCallback], None],
        pair_name: str
    ) -&gt; threading.Thread:
        thread = threading.Thread(
            target=self.start_price_socket, args=[on_update, pair_name]
        )
        thread.start()
        return thread

    def start_user_update_socket_threaded(
        self, on_update: typing.Callable[[typing.Union[AbstractExchangeHandler.OrderUpdate]], None]
    ) -&gt; threading.Thread:
        thread = threading.Thread(
            target=self.start_user_update_socket, args=[on_update]
        )
        thread.start()
        return thread

    @dataclass
    class NewOrderData:
        orderID: str
        client_orderID: str

    @abc.abstractmethod
    async def create_order(
        self, symbol: str, side: str, price: float, volume: float
    ) -&gt; AbstractExchangeHandler.NewOrderData:
        ...

    @abc.abstractmethod
    async def cancel_order(self, order_id: int) -&gt; None:
        ...

    @staticmethod
    def generate_client_order_id() -&gt; str:
        return base64.b32encode(
            hashlib.sha1(bytes(str(datetime.now()), &#34;utf-8&#34;)).digest()
        ).decode(&#34;ascii&#34;)


class BitmexExchangeHandler(AbstractExchangeHandler):
    domen = &#34;wss://www.bitmex.com&#34;

    # Generates an API signature.
    # A signature is HMAC_SHA256(secret, verb + path + nonce + data), hex encoded.
    # Verb must be uppercased, url is relative, nonce must be an increasing 64-bit integer
    # and the data, if present, must be JSON without whitespace between keys.
    @staticmethod
    def bitmex_signature(apiSecret, verb, url, nonce, postdict=None):
        &#34;&#34;&#34;Given an API Secret key and data, create a BitMEX-compatible signature.&#34;&#34;&#34;
        data = &#39;&#39;
        if postdict:
            # separators remove spaces from json
            # BitMEX expects signatures from JSON built without spaces
            data = json.dumps(postdict, separators=(&#39;,&#39;, &#39;:&#39;))
        parsedURL = urllib.parse.urlparse(url)
        path = parsedURL.path
        if parsedURL.query:
            path = path + &#39;?&#39; + parsedURL.query
        # print(&#34;Computing HMAC: %s&#34; % verb + path + str(nonce) + data)
        message = (verb + path + str(nonce) + data).encode(&#39;utf-8&#39;)

        signature = hmac.new(apiSecret.encode(&#39;utf-8&#39;), message, digestmod=hashlib.sha256).hexdigest()
        return signature

    def __init__(self, public_key, private_key):
        super().__init__(public_key, private_key)
        self._client = bitmex.bitmex(
            test=False, api_key=self._public_key, api_secret=self._private_key
        )
        self.logger = init_logger(self.__class__.__name__)

    def start_kline_socket(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.KlineCallback], None],
        candle_type: str,
        pair_name: str,
    ) -&gt; None:

        def __on_message(ws, msg):
            msg = json.loads(msg)
            if &#34;action&#34; in msg and msg[&#34;action&#34;] == &#34;insert&#34;:
                data = msg[&#34;data&#34;][0]
                epoch = datetime.utcfromtimestamp(0)
                data = {
                    &#34;time&#34;: datetime.strptime(data[&#34;timestamp&#34;], &#34;%Y-%m-%dT%H:%M:%S.000Z&#34;),
                    &#34;open&#34;: data[&#34;open&#34;],
                    &#34;high&#34;: data[&#34;high&#34;],
                    &#34;low&#34;: data[&#34;low&#34;],
                    &#34;close&#34;: data[&#34;close&#34;],
                    &#34;volume&#34;: data[&#34;volume&#34;],
                    &#34;message&#34;: msg,
                }
                on_update(AbstractExchangeHandler.KlineCallback(**data))

        def __on_error(ws, error):
            self.logger.error(&#34;Error occured in %s: %s&#34;, ws, error)

        def __on_close(ws):
            self.logger.warning(&#34;Websocket is restarting, might have lost some data&#34;)
            self.start_kline_socket(on_update, candle_type, pair_name)

        self.logger.info(&#34;Starting kline websocket&#34;)

        ws = websocket.WebSocketApp(
            f&#34;{self.domen}/realtime?subscribe=tradeBin{candle_type}:{pair_name}&#34;,
            on_message=__on_message,
            on_error=__on_error,
            on_close=__on_close,
        )
        ws.run_forever()

    def start_price_socket(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.PriceCallback], None],
        pair_name: str
    ) -&gt; None:
        def __on_message(ws, msg):
            msg = json.loads(msg)
            if &#39;data&#39; in msg and &#39;lastPrice&#39; in msg[&#39;data&#39;][0]:
                price = msg[&#39;data&#39;][0][&#39;lastPrice&#39;]
                on_update(AbstractExchangeHandler.PriceCallback(price=price))

        def __on_error(ws, error):
            self.logger.error(&#34;Error occured in %s: %s&#34;, ws, error)

        def __on_close(ws):
            self.logger.warning(&#34;Websocket is restarting, might have lost some data&#34;)
            self.start_price_socket(on_update, pair_name)

        self.logger.info(&#34;Starting price websocket&#34;)

        ws = websocket.WebSocketApp(
            f&#34;{self.domen}/realtime?subscribe=instrument:{pair_name}&#34;,
            on_message = __on_message,
            on_error = __on_error,
            on_close = __on_close
        )
        ws.run_forever()

    def start_user_update_socket(
        self, on_update: typing.Callable[[AbstractExchangeHandler.UserUpdate], None]
    ) -&gt; None:
        self.logger.info(&#39;Starting user update socket&#39;)
        
        # Switch these comments to use testnet instead.
        # BITMEX_URL = &#34;wss://testnet.bitmex.com&#34;
        BITMEX_URL = self.domen

        VERB = &#34;GET&#34;
        ENDPOINT = &#34;/realtime&#34;

        # These are not real keys - replace them with your keys.
        API_KEY, API_SECRET = self._public_key, self._private_key

        # This is up to you, most use microtime but you may have your own scheme so long as it&#39;s increasing
        # and doesn&#39;t repeat.
        expires = int(time.time()) + 60 * 60
        # See signature generation reference at https://www.bitmex.com/app/apiKeys
        signature = BitmexExchangeHandler.bitmex_signature(API_SECRET, VERB, ENDPOINT, expires)

        # Initial connection - BitMEX sends a welcome message.
        ws = websocket.create_connection(BITMEX_URL + ENDPOINT)
        result = ws.recv()

        # Send API Key with signed message.
        request = {&#34;op&#34;: &#34;authKeyExpires&#34;, &#34;args&#34;: [API_KEY, expires, signature]}
        ws.send(json.dumps(request))
        result = ws.recv()

        # Send a request that requires authorization.
        request = {&#34;op&#34;: &#34;subscribe&#34;, &#34;args&#34;: &#34;order&#34;}
        ws.send(json.dumps(request))

        _update_dict: typing.Mapping[str, typing.Dict[str, typing.Any]] = {}

        cst: typing.Dict[str, float] = {&#34;XBTUSD&#34;: 10**-8}

        def __process_msg(msg):
            try:
                msg = json.loads(msg)
            except:
                return

            if &#39;data&#39; in msg:
                for data in msg[&#39;data&#39;]:
                    if data[&#39;orderID&#39;] not in _update_dict:
                        _update_dict[data[&#39;orderID&#39;]] = {}

                    for key, value in data.items():
                        _update_dict[data[&#39;orderID&#39;]][key] = value

                if &#39;action&#39; in msg and (msg[&#39;action&#39;] == &#39;insert&#39; or msg[&#39;action&#39;] == &#39;update&#39;):
                    for data in msg[&#39;data&#39;]:
                        if &#39;ordStatus&#39; in data:
                            fee_payed = 0
                            if data[&#39;ordStatus&#39;] == &#39;Filled&#39;:
                                pair_name = &#34;XBTUSD&#34;
                                corresponding_trades = self._client.Execution.Execution_getTradeHistory(symbol=pair_name, filter=json.dumps({&#39;clOrdID&#39;: data[&#39;clOrdID&#39;]})).result()[0]
                                fee_payed = sum([trade[&#39;execComm&#39;] * cst[pair_name] for trade in corresponding_trades])

                            order_data = _update_dict[data[&#39;orderID&#39;]]
                            
                            volume_side = 1 if order_data[&#39;side&#39;] == &#34;Buy&#34; else -1

                            dic = {
                                &#39;orderID&#39;: order_data[&#39;orderID&#39;],
                                &#39;client_orderID&#39;: order_data[&#39;clOrdID&#39;],
                                &#39;status&#39;: order_data[&#39;ordStatus&#39;].upper(),
                                &#39;price&#39;: float(order_data[&#39;price&#39;]),
                                &#39;average_price&#39;: float(order_data[&#39;avgPx&#39;]) if &#39;avgPx&#39; in order_data and order_data[&#39;avgPx&#39;] is not None else None,
                                &#39;fee&#39;: fee_payed,
                                &#39;fee_asset&#39;: &#39;XBT&#39;,
                                &#39;volume_realized&#39;: float(order_data[&#39;cumQty&#39;]) * volume_side if &#39;cumQty&#39; in order_data and order_data[&#39;cumQty&#39;] is not None else 0,
                                &#39;volume&#39;: float(order_data[&#39;orderQty&#39;]) * volume_side,
                                &#39;time&#39;: datetime.strptime(order_data[&#39;timestamp&#39;][:-1] + &#39;000&#39;, &#39;%Y-%m-%dT%H:%M:%S.%f&#39;),
                                &#39;message&#39;: order_data
                            }

                            if dic[&#39;status&#39;] == &#39;PARTIALLYFILLED&#39;:
                                dic[&#39;status&#39;] = &#39;PARTIALLY_FILLED&#39;

                            on_update(AbstractExchangeHandler.OrderUpdate(**dic))
        
        def __ping():
            ws.send(&#39;ping&#39;)
            timer = threading.Timer(10, __ping)
            timer.start()

        timer = threading.Timer(10, __ping)
        timer.start()

        while True:
            try:
                result = ws.recv()
                __process_msg(result)
            except Exception as e:
                self.logger.error(f&#34;An error happened in user update socket [{e}]: {result}, restarting...&#34;)
                timer.cancel()
                raise
                self.start_user_update_socket(on_update)
                break


    async def create_order(
        self, symbol: str, side: str, price: float, volume: float
    ) -&gt; AbstractExchangeHandler.NewOrderData:
        result = self._client.Order.Order_new(
            clOrdID=self.generate_client_order_id(),
            symbol=symbol,
            side=side,
            orderQty=volume,
            price=price,
            ordType=&#34;Limit&#34;,
        ).result()[0]

        return AbstractExchangeHandler.NewOrderData(orderID=result[&#34;orderID&#34;], client_orderID=result[&#34;clOrdID&#34;])

    async def cancel_order(self, order_id: int) -&gt; None:
        self._client.Order.Order_cancel(orderID=order_id).result()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler"><code class="flex name class">
<span>class <span class="ident">AbstractExchangeHandler</span></span>
<span>(</span><span>public_key: str, private_key: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractExchangeHandler(metaclass=abc.ABCMeta):
    def __init__(self, public_key: str, private_key: str):
        self._public_key = public_key
        self._private_key = private_key

    @dataclass
    class KlineCallback:
        time: datetime
        open: float
        high: float
        low: float
        close: float
        volume: float
        message: typing.Any

    @abc.abstractmethod
    def start_kline_socket(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.KlineCallback], None],
        candle_type: str,
        pair_name: str,
    ) -&gt; None:
        ...

    @dataclass
    class PriceCallback:
        price: float

    @abc.abstractmethod
    def start_price_socket(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.PriceCallback], None],
        pair_name: str
    ) -&gt; None:
        ...

    @dataclass
    class OrderUpdate:
        orderID: str
        client_orderID: str
        status: str
        price: float
        average_price: float
        fee: float
        fee_asset: str
        volume: float
        volume_realized: float
        time: datetime
        message: typing.Any

    UserUpdate = typing.Union[OrderUpdate]

    @abc.abstractmethod
    def start_user_update_socket(
        self, on_update: typing.Callable[[AbstractExchangeHandler.UserUpdate], None]
    ) -&gt; None:
        ...

    def start_kline_socket_threaded(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.KlineCallback], None],
        candle_type: str,
        pair_name: str,
    ) -&gt; threading.Thread:
        thread = threading.Thread(
            target=self.start_kline_socket, args=[on_update, candle_type, pair_name]
        )
        thread.start()
        return thread

    def start_price_socket_threaded(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.PriceCallback], None],
        pair_name: str
    ) -&gt; threading.Thread:
        thread = threading.Thread(
            target=self.start_price_socket, args=[on_update, pair_name]
        )
        thread.start()
        return thread

    def start_user_update_socket_threaded(
        self, on_update: typing.Callable[[typing.Union[AbstractExchangeHandler.OrderUpdate]], None]
    ) -&gt; threading.Thread:
        thread = threading.Thread(
            target=self.start_user_update_socket, args=[on_update]
        )
        thread.start()
        return thread

    @dataclass
    class NewOrderData:
        orderID: str
        client_orderID: str

    @abc.abstractmethod
    async def create_order(
        self, symbol: str, side: str, price: float, volume: float
    ) -&gt; AbstractExchangeHandler.NewOrderData:
        ...

    @abc.abstractmethod
    async def cancel_order(self, order_id: int) -&gt; None:
        ...

    @staticmethod
    def generate_client_order_id() -&gt; str:
        return base64.b32encode(
            hashlib.sha1(bytes(str(datetime.now()), &#34;utf-8&#34;)).digest()
        ).decode(&#34;ascii&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sourse.exchange_handlers.BitmexExchangeHandler" href="#sourse.exchange_handlers.BitmexExchangeHandler">BitmexExchangeHandler</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback"><code class="name">var <span class="ident">KlineCallback</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.NewOrderData"><code class="name">var <span class="ident">NewOrderData</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.OrderUpdate"><code class="name">var <span class="ident">OrderUpdate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback"><code class="name">var <span class="ident">PriceCallback</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.UserUpdate"><code class="name">var <span class="ident">UserUpdate</span></code></dt>
<dd>
<div class="desc"><p>OrderUpdate(orderID: 'str', client_orderID: 'str', status: 'str', price: 'float', average_price: 'float', fee: 'float', fee_asset: 'str', volume: 'float', volume_realized: 'float', time: 'datetime', message: 'typing.Any')</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.generate_client_order_id"><code class="name flex">
<span>def <span class="ident">generate_client_order_id</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def generate_client_order_id() -&gt; str:
    return base64.b32encode(
        hashlib.sha1(bytes(str(datetime.now()), &#34;utf-8&#34;)).digest()
    ).decode(&#34;ascii&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.cancel_order"><code class="name flex">
<span>async def <span class="ident">cancel_order</span></span>(<span>self, order_id: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
async def cancel_order(self, order_id: int) -&gt; None:
    ...</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.create_order"><code class="name flex">
<span>async def <span class="ident">create_order</span></span>(<span>self, symbol: str, side: str, price: float, volume: float) ‑> <a title="sourse.exchange_handlers.AbstractExchangeHandler.NewOrderData" href="#sourse.exchange_handlers.AbstractExchangeHandler.NewOrderData">AbstractExchangeHandler.NewOrderData</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_order(
    self, symbol: str, side: str, price: float, volume: float
) -&gt; AbstractExchangeHandler.NewOrderData:
    ...</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.start_kline_socket"><code class="name flex">
<span>def <span class="ident">start_kline_socket</span></span>(<span>self, on_update: typing.Callable[[<a title="sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback" href="#sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback">AbstractExchangeHandler.KlineCallback</a>], None], candle_type: str, pair_name: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def start_kline_socket(
    self,
    on_update: typing.Callable[[AbstractExchangeHandler.KlineCallback], None],
    candle_type: str,
    pair_name: str,
) -&gt; None:
    ...</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.start_kline_socket_threaded"><code class="name flex">
<span>def <span class="ident">start_kline_socket_threaded</span></span>(<span>self, on_update: typing.Callable[[<a title="sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback" href="#sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback">AbstractExchangeHandler.KlineCallback</a>], None], candle_type: str, pair_name: str) ‑> threading.Thread</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_kline_socket_threaded(
    self,
    on_update: typing.Callable[[AbstractExchangeHandler.KlineCallback], None],
    candle_type: str,
    pair_name: str,
) -&gt; threading.Thread:
    thread = threading.Thread(
        target=self.start_kline_socket, args=[on_update, candle_type, pair_name]
    )
    thread.start()
    return thread</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.start_price_socket"><code class="name flex">
<span>def <span class="ident">start_price_socket</span></span>(<span>self, on_update: typing.Callable[[<a title="sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback" href="#sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback">AbstractExchangeHandler.PriceCallback</a>], None], pair_name: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def start_price_socket(
    self,
    on_update: typing.Callable[[AbstractExchangeHandler.PriceCallback], None],
    pair_name: str
) -&gt; None:
    ...</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.start_price_socket_threaded"><code class="name flex">
<span>def <span class="ident">start_price_socket_threaded</span></span>(<span>self, on_update: typing.Callable[[<a title="sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback" href="#sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback">AbstractExchangeHandler.PriceCallback</a>], None], pair_name: str) ‑> threading.Thread</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_price_socket_threaded(
    self,
    on_update: typing.Callable[[AbstractExchangeHandler.PriceCallback], None],
    pair_name: str
) -&gt; threading.Thread:
    thread = threading.Thread(
        target=self.start_price_socket, args=[on_update, pair_name]
    )
    thread.start()
    return thread</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.start_user_update_socket"><code class="name flex">
<span>def <span class="ident">start_user_update_socket</span></span>(<span>self, on_update: typing.Callable[[<a title="sourse.exchange_handlers.AbstractExchangeHandler.UserUpdate" href="#sourse.exchange_handlers.AbstractExchangeHandler.UserUpdate">AbstractExchangeHandler.UserUpdate</a>], None]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def start_user_update_socket(
    self, on_update: typing.Callable[[AbstractExchangeHandler.UserUpdate], None]
) -&gt; None:
    ...</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.AbstractExchangeHandler.start_user_update_socket_threaded"><code class="name flex">
<span>def <span class="ident">start_user_update_socket_threaded</span></span>(<span>self, on_update: typing.Callable[[typing.Union[<a title="sourse.exchange_handlers.AbstractExchangeHandler.OrderUpdate" href="#sourse.exchange_handlers.AbstractExchangeHandler.OrderUpdate">AbstractExchangeHandler.OrderUpdate</a>]], None]) ‑> threading.Thread</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_user_update_socket_threaded(
    self, on_update: typing.Callable[[typing.Union[AbstractExchangeHandler.OrderUpdate]], None]
) -&gt; threading.Thread:
    thread = threading.Thread(
        target=self.start_user_update_socket, args=[on_update]
    )
    thread.start()
    return thread</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sourse.exchange_handlers.BitmexExchangeHandler"><code class="flex name class">
<span>class <span class="ident">BitmexExchangeHandler</span></span>
<span>(</span><span>public_key, private_key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BitmexExchangeHandler(AbstractExchangeHandler):
    domen = &#34;wss://www.bitmex.com&#34;

    # Generates an API signature.
    # A signature is HMAC_SHA256(secret, verb + path + nonce + data), hex encoded.
    # Verb must be uppercased, url is relative, nonce must be an increasing 64-bit integer
    # and the data, if present, must be JSON without whitespace between keys.
    @staticmethod
    def bitmex_signature(apiSecret, verb, url, nonce, postdict=None):
        &#34;&#34;&#34;Given an API Secret key and data, create a BitMEX-compatible signature.&#34;&#34;&#34;
        data = &#39;&#39;
        if postdict:
            # separators remove spaces from json
            # BitMEX expects signatures from JSON built without spaces
            data = json.dumps(postdict, separators=(&#39;,&#39;, &#39;:&#39;))
        parsedURL = urllib.parse.urlparse(url)
        path = parsedURL.path
        if parsedURL.query:
            path = path + &#39;?&#39; + parsedURL.query
        # print(&#34;Computing HMAC: %s&#34; % verb + path + str(nonce) + data)
        message = (verb + path + str(nonce) + data).encode(&#39;utf-8&#39;)

        signature = hmac.new(apiSecret.encode(&#39;utf-8&#39;), message, digestmod=hashlib.sha256).hexdigest()
        return signature

    def __init__(self, public_key, private_key):
        super().__init__(public_key, private_key)
        self._client = bitmex.bitmex(
            test=False, api_key=self._public_key, api_secret=self._private_key
        )
        self.logger = init_logger(self.__class__.__name__)

    def start_kline_socket(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.KlineCallback], None],
        candle_type: str,
        pair_name: str,
    ) -&gt; None:

        def __on_message(ws, msg):
            msg = json.loads(msg)
            if &#34;action&#34; in msg and msg[&#34;action&#34;] == &#34;insert&#34;:
                data = msg[&#34;data&#34;][0]
                epoch = datetime.utcfromtimestamp(0)
                data = {
                    &#34;time&#34;: datetime.strptime(data[&#34;timestamp&#34;], &#34;%Y-%m-%dT%H:%M:%S.000Z&#34;),
                    &#34;open&#34;: data[&#34;open&#34;],
                    &#34;high&#34;: data[&#34;high&#34;],
                    &#34;low&#34;: data[&#34;low&#34;],
                    &#34;close&#34;: data[&#34;close&#34;],
                    &#34;volume&#34;: data[&#34;volume&#34;],
                    &#34;message&#34;: msg,
                }
                on_update(AbstractExchangeHandler.KlineCallback(**data))

        def __on_error(ws, error):
            self.logger.error(&#34;Error occured in %s: %s&#34;, ws, error)

        def __on_close(ws):
            self.logger.warning(&#34;Websocket is restarting, might have lost some data&#34;)
            self.start_kline_socket(on_update, candle_type, pair_name)

        self.logger.info(&#34;Starting kline websocket&#34;)

        ws = websocket.WebSocketApp(
            f&#34;{self.domen}/realtime?subscribe=tradeBin{candle_type}:{pair_name}&#34;,
            on_message=__on_message,
            on_error=__on_error,
            on_close=__on_close,
        )
        ws.run_forever()

    def start_price_socket(
        self,
        on_update: typing.Callable[[AbstractExchangeHandler.PriceCallback], None],
        pair_name: str
    ) -&gt; None:
        def __on_message(ws, msg):
            msg = json.loads(msg)
            if &#39;data&#39; in msg and &#39;lastPrice&#39; in msg[&#39;data&#39;][0]:
                price = msg[&#39;data&#39;][0][&#39;lastPrice&#39;]
                on_update(AbstractExchangeHandler.PriceCallback(price=price))

        def __on_error(ws, error):
            self.logger.error(&#34;Error occured in %s: %s&#34;, ws, error)

        def __on_close(ws):
            self.logger.warning(&#34;Websocket is restarting, might have lost some data&#34;)
            self.start_price_socket(on_update, pair_name)

        self.logger.info(&#34;Starting price websocket&#34;)

        ws = websocket.WebSocketApp(
            f&#34;{self.domen}/realtime?subscribe=instrument:{pair_name}&#34;,
            on_message = __on_message,
            on_error = __on_error,
            on_close = __on_close
        )
        ws.run_forever()

    def start_user_update_socket(
        self, on_update: typing.Callable[[AbstractExchangeHandler.UserUpdate], None]
    ) -&gt; None:
        self.logger.info(&#39;Starting user update socket&#39;)
        
        # Switch these comments to use testnet instead.
        # BITMEX_URL = &#34;wss://testnet.bitmex.com&#34;
        BITMEX_URL = self.domen

        VERB = &#34;GET&#34;
        ENDPOINT = &#34;/realtime&#34;

        # These are not real keys - replace them with your keys.
        API_KEY, API_SECRET = self._public_key, self._private_key

        # This is up to you, most use microtime but you may have your own scheme so long as it&#39;s increasing
        # and doesn&#39;t repeat.
        expires = int(time.time()) + 60 * 60
        # See signature generation reference at https://www.bitmex.com/app/apiKeys
        signature = BitmexExchangeHandler.bitmex_signature(API_SECRET, VERB, ENDPOINT, expires)

        # Initial connection - BitMEX sends a welcome message.
        ws = websocket.create_connection(BITMEX_URL + ENDPOINT)
        result = ws.recv()

        # Send API Key with signed message.
        request = {&#34;op&#34;: &#34;authKeyExpires&#34;, &#34;args&#34;: [API_KEY, expires, signature]}
        ws.send(json.dumps(request))
        result = ws.recv()

        # Send a request that requires authorization.
        request = {&#34;op&#34;: &#34;subscribe&#34;, &#34;args&#34;: &#34;order&#34;}
        ws.send(json.dumps(request))

        _update_dict: typing.Mapping[str, typing.Dict[str, typing.Any]] = {}

        cst: typing.Dict[str, float] = {&#34;XBTUSD&#34;: 10**-8}

        def __process_msg(msg):
            try:
                msg = json.loads(msg)
            except:
                return

            if &#39;data&#39; in msg:
                for data in msg[&#39;data&#39;]:
                    if data[&#39;orderID&#39;] not in _update_dict:
                        _update_dict[data[&#39;orderID&#39;]] = {}

                    for key, value in data.items():
                        _update_dict[data[&#39;orderID&#39;]][key] = value

                if &#39;action&#39; in msg and (msg[&#39;action&#39;] == &#39;insert&#39; or msg[&#39;action&#39;] == &#39;update&#39;):
                    for data in msg[&#39;data&#39;]:
                        if &#39;ordStatus&#39; in data:
                            fee_payed = 0
                            if data[&#39;ordStatus&#39;] == &#39;Filled&#39;:
                                pair_name = &#34;XBTUSD&#34;
                                corresponding_trades = self._client.Execution.Execution_getTradeHistory(symbol=pair_name, filter=json.dumps({&#39;clOrdID&#39;: data[&#39;clOrdID&#39;]})).result()[0]
                                fee_payed = sum([trade[&#39;execComm&#39;] * cst[pair_name] for trade in corresponding_trades])

                            order_data = _update_dict[data[&#39;orderID&#39;]]
                            
                            volume_side = 1 if order_data[&#39;side&#39;] == &#34;Buy&#34; else -1

                            dic = {
                                &#39;orderID&#39;: order_data[&#39;orderID&#39;],
                                &#39;client_orderID&#39;: order_data[&#39;clOrdID&#39;],
                                &#39;status&#39;: order_data[&#39;ordStatus&#39;].upper(),
                                &#39;price&#39;: float(order_data[&#39;price&#39;]),
                                &#39;average_price&#39;: float(order_data[&#39;avgPx&#39;]) if &#39;avgPx&#39; in order_data and order_data[&#39;avgPx&#39;] is not None else None,
                                &#39;fee&#39;: fee_payed,
                                &#39;fee_asset&#39;: &#39;XBT&#39;,
                                &#39;volume_realized&#39;: float(order_data[&#39;cumQty&#39;]) * volume_side if &#39;cumQty&#39; in order_data and order_data[&#39;cumQty&#39;] is not None else 0,
                                &#39;volume&#39;: float(order_data[&#39;orderQty&#39;]) * volume_side,
                                &#39;time&#39;: datetime.strptime(order_data[&#39;timestamp&#39;][:-1] + &#39;000&#39;, &#39;%Y-%m-%dT%H:%M:%S.%f&#39;),
                                &#39;message&#39;: order_data
                            }

                            if dic[&#39;status&#39;] == &#39;PARTIALLYFILLED&#39;:
                                dic[&#39;status&#39;] = &#39;PARTIALLY_FILLED&#39;

                            on_update(AbstractExchangeHandler.OrderUpdate(**dic))
        
        def __ping():
            ws.send(&#39;ping&#39;)
            timer = threading.Timer(10, __ping)
            timer.start()

        timer = threading.Timer(10, __ping)
        timer.start()

        while True:
            try:
                result = ws.recv()
                __process_msg(result)
            except Exception as e:
                self.logger.error(f&#34;An error happened in user update socket [{e}]: {result}, restarting...&#34;)
                timer.cancel()
                raise
                self.start_user_update_socket(on_update)
                break


    async def create_order(
        self, symbol: str, side: str, price: float, volume: float
    ) -&gt; AbstractExchangeHandler.NewOrderData:
        result = self._client.Order.Order_new(
            clOrdID=self.generate_client_order_id(),
            symbol=symbol,
            side=side,
            orderQty=volume,
            price=price,
            ordType=&#34;Limit&#34;,
        ).result()[0]

        return AbstractExchangeHandler.NewOrderData(orderID=result[&#34;orderID&#34;], client_orderID=result[&#34;clOrdID&#34;])

    async def cancel_order(self, order_id: int) -&gt; None:
        self._client.Order.Order_cancel(orderID=order_id).result()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sourse.exchange_handlers.AbstractExchangeHandler" href="#sourse.exchange_handlers.AbstractExchangeHandler">AbstractExchangeHandler</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sourse.exchange_handlers.BitmexExchangeHandler.domen"><code class="name">var <span class="ident">domen</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sourse.exchange_handlers.BitmexExchangeHandler.bitmex_signature"><code class="name flex">
<span>def <span class="ident">bitmex_signature</span></span>(<span>apiSecret, verb, url, nonce, postdict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Given an API Secret key and data, create a BitMEX-compatible signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def bitmex_signature(apiSecret, verb, url, nonce, postdict=None):
    &#34;&#34;&#34;Given an API Secret key and data, create a BitMEX-compatible signature.&#34;&#34;&#34;
    data = &#39;&#39;
    if postdict:
        # separators remove spaces from json
        # BitMEX expects signatures from JSON built without spaces
        data = json.dumps(postdict, separators=(&#39;,&#39;, &#39;:&#39;))
    parsedURL = urllib.parse.urlparse(url)
    path = parsedURL.path
    if parsedURL.query:
        path = path + &#39;?&#39; + parsedURL.query
    # print(&#34;Computing HMAC: %s&#34; % verb + path + str(nonce) + data)
    message = (verb + path + str(nonce) + data).encode(&#39;utf-8&#39;)

    signature = hmac.new(apiSecret.encode(&#39;utf-8&#39;), message, digestmod=hashlib.sha256).hexdigest()
    return signature</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sourse.exchange_handlers.BitmexExchangeHandler.cancel_order"><code class="name flex">
<span>async def <span class="ident">cancel_order</span></span>(<span>self, order_id: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def cancel_order(self, order_id: int) -&gt; None:
    self._client.Order.Order_cancel(orderID=order_id).result()</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.BitmexExchangeHandler.create_order"><code class="name flex">
<span>async def <span class="ident">create_order</span></span>(<span>self, symbol: str, side: str, price: float, volume: float) ‑> <a title="sourse.exchange_handlers.AbstractExchangeHandler.NewOrderData" href="#sourse.exchange_handlers.AbstractExchangeHandler.NewOrderData">AbstractExchangeHandler.NewOrderData</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_order(
    self, symbol: str, side: str, price: float, volume: float
) -&gt; AbstractExchangeHandler.NewOrderData:
    result = self._client.Order.Order_new(
        clOrdID=self.generate_client_order_id(),
        symbol=symbol,
        side=side,
        orderQty=volume,
        price=price,
        ordType=&#34;Limit&#34;,
    ).result()[0]

    return AbstractExchangeHandler.NewOrderData(orderID=result[&#34;orderID&#34;], client_orderID=result[&#34;clOrdID&#34;])</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.BitmexExchangeHandler.start_kline_socket"><code class="name flex">
<span>def <span class="ident">start_kline_socket</span></span>(<span>self, on_update: typing.Callable[[<a title="sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback" href="#sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback">AbstractExchangeHandler.KlineCallback</a>], None], candle_type: str, pair_name: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_kline_socket(
    self,
    on_update: typing.Callable[[AbstractExchangeHandler.KlineCallback], None],
    candle_type: str,
    pair_name: str,
) -&gt; None:

    def __on_message(ws, msg):
        msg = json.loads(msg)
        if &#34;action&#34; in msg and msg[&#34;action&#34;] == &#34;insert&#34;:
            data = msg[&#34;data&#34;][0]
            epoch = datetime.utcfromtimestamp(0)
            data = {
                &#34;time&#34;: datetime.strptime(data[&#34;timestamp&#34;], &#34;%Y-%m-%dT%H:%M:%S.000Z&#34;),
                &#34;open&#34;: data[&#34;open&#34;],
                &#34;high&#34;: data[&#34;high&#34;],
                &#34;low&#34;: data[&#34;low&#34;],
                &#34;close&#34;: data[&#34;close&#34;],
                &#34;volume&#34;: data[&#34;volume&#34;],
                &#34;message&#34;: msg,
            }
            on_update(AbstractExchangeHandler.KlineCallback(**data))

    def __on_error(ws, error):
        self.logger.error(&#34;Error occured in %s: %s&#34;, ws, error)

    def __on_close(ws):
        self.logger.warning(&#34;Websocket is restarting, might have lost some data&#34;)
        self.start_kline_socket(on_update, candle_type, pair_name)

    self.logger.info(&#34;Starting kline websocket&#34;)

    ws = websocket.WebSocketApp(
        f&#34;{self.domen}/realtime?subscribe=tradeBin{candle_type}:{pair_name}&#34;,
        on_message=__on_message,
        on_error=__on_error,
        on_close=__on_close,
    )
    ws.run_forever()</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.BitmexExchangeHandler.start_price_socket"><code class="name flex">
<span>def <span class="ident">start_price_socket</span></span>(<span>self, on_update: typing.Callable[[<a title="sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback" href="#sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback">AbstractExchangeHandler.PriceCallback</a>], None], pair_name: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_price_socket(
    self,
    on_update: typing.Callable[[AbstractExchangeHandler.PriceCallback], None],
    pair_name: str
) -&gt; None:
    def __on_message(ws, msg):
        msg = json.loads(msg)
        if &#39;data&#39; in msg and &#39;lastPrice&#39; in msg[&#39;data&#39;][0]:
            price = msg[&#39;data&#39;][0][&#39;lastPrice&#39;]
            on_update(AbstractExchangeHandler.PriceCallback(price=price))

    def __on_error(ws, error):
        self.logger.error(&#34;Error occured in %s: %s&#34;, ws, error)

    def __on_close(ws):
        self.logger.warning(&#34;Websocket is restarting, might have lost some data&#34;)
        self.start_price_socket(on_update, pair_name)

    self.logger.info(&#34;Starting price websocket&#34;)

    ws = websocket.WebSocketApp(
        f&#34;{self.domen}/realtime?subscribe=instrument:{pair_name}&#34;,
        on_message = __on_message,
        on_error = __on_error,
        on_close = __on_close
    )
    ws.run_forever()</code></pre>
</details>
</dd>
<dt id="sourse.exchange_handlers.BitmexExchangeHandler.start_user_update_socket"><code class="name flex">
<span>def <span class="ident">start_user_update_socket</span></span>(<span>self, on_update: typing.Callable[[<a title="sourse.exchange_handlers.AbstractExchangeHandler.UserUpdate" href="#sourse.exchange_handlers.AbstractExchangeHandler.UserUpdate">AbstractExchangeHandler.UserUpdate</a>], None]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_user_update_socket(
    self, on_update: typing.Callable[[AbstractExchangeHandler.UserUpdate], None]
) -&gt; None:
    self.logger.info(&#39;Starting user update socket&#39;)
    
    # Switch these comments to use testnet instead.
    # BITMEX_URL = &#34;wss://testnet.bitmex.com&#34;
    BITMEX_URL = self.domen

    VERB = &#34;GET&#34;
    ENDPOINT = &#34;/realtime&#34;

    # These are not real keys - replace them with your keys.
    API_KEY, API_SECRET = self._public_key, self._private_key

    # This is up to you, most use microtime but you may have your own scheme so long as it&#39;s increasing
    # and doesn&#39;t repeat.
    expires = int(time.time()) + 60 * 60
    # See signature generation reference at https://www.bitmex.com/app/apiKeys
    signature = BitmexExchangeHandler.bitmex_signature(API_SECRET, VERB, ENDPOINT, expires)

    # Initial connection - BitMEX sends a welcome message.
    ws = websocket.create_connection(BITMEX_URL + ENDPOINT)
    result = ws.recv()

    # Send API Key with signed message.
    request = {&#34;op&#34;: &#34;authKeyExpires&#34;, &#34;args&#34;: [API_KEY, expires, signature]}
    ws.send(json.dumps(request))
    result = ws.recv()

    # Send a request that requires authorization.
    request = {&#34;op&#34;: &#34;subscribe&#34;, &#34;args&#34;: &#34;order&#34;}
    ws.send(json.dumps(request))

    _update_dict: typing.Mapping[str, typing.Dict[str, typing.Any]] = {}

    cst: typing.Dict[str, float] = {&#34;XBTUSD&#34;: 10**-8}

    def __process_msg(msg):
        try:
            msg = json.loads(msg)
        except:
            return

        if &#39;data&#39; in msg:
            for data in msg[&#39;data&#39;]:
                if data[&#39;orderID&#39;] not in _update_dict:
                    _update_dict[data[&#39;orderID&#39;]] = {}

                for key, value in data.items():
                    _update_dict[data[&#39;orderID&#39;]][key] = value

            if &#39;action&#39; in msg and (msg[&#39;action&#39;] == &#39;insert&#39; or msg[&#39;action&#39;] == &#39;update&#39;):
                for data in msg[&#39;data&#39;]:
                    if &#39;ordStatus&#39; in data:
                        fee_payed = 0
                        if data[&#39;ordStatus&#39;] == &#39;Filled&#39;:
                            pair_name = &#34;XBTUSD&#34;
                            corresponding_trades = self._client.Execution.Execution_getTradeHistory(symbol=pair_name, filter=json.dumps({&#39;clOrdID&#39;: data[&#39;clOrdID&#39;]})).result()[0]
                            fee_payed = sum([trade[&#39;execComm&#39;] * cst[pair_name] for trade in corresponding_trades])

                        order_data = _update_dict[data[&#39;orderID&#39;]]
                        
                        volume_side = 1 if order_data[&#39;side&#39;] == &#34;Buy&#34; else -1

                        dic = {
                            &#39;orderID&#39;: order_data[&#39;orderID&#39;],
                            &#39;client_orderID&#39;: order_data[&#39;clOrdID&#39;],
                            &#39;status&#39;: order_data[&#39;ordStatus&#39;].upper(),
                            &#39;price&#39;: float(order_data[&#39;price&#39;]),
                            &#39;average_price&#39;: float(order_data[&#39;avgPx&#39;]) if &#39;avgPx&#39; in order_data and order_data[&#39;avgPx&#39;] is not None else None,
                            &#39;fee&#39;: fee_payed,
                            &#39;fee_asset&#39;: &#39;XBT&#39;,
                            &#39;volume_realized&#39;: float(order_data[&#39;cumQty&#39;]) * volume_side if &#39;cumQty&#39; in order_data and order_data[&#39;cumQty&#39;] is not None else 0,
                            &#39;volume&#39;: float(order_data[&#39;orderQty&#39;]) * volume_side,
                            &#39;time&#39;: datetime.strptime(order_data[&#39;timestamp&#39;][:-1] + &#39;000&#39;, &#39;%Y-%m-%dT%H:%M:%S.%f&#39;),
                            &#39;message&#39;: order_data
                        }

                        if dic[&#39;status&#39;] == &#39;PARTIALLYFILLED&#39;:
                            dic[&#39;status&#39;] = &#39;PARTIALLY_FILLED&#39;

                        on_update(AbstractExchangeHandler.OrderUpdate(**dic))
    
    def __ping():
        ws.send(&#39;ping&#39;)
        timer = threading.Timer(10, __ping)
        timer.start()

    timer = threading.Timer(10, __ping)
    timer.start()

    while True:
        try:
            result = ws.recv()
            __process_msg(result)
        except Exception as e:
            self.logger.error(f&#34;An error happened in user update socket [{e}]: {result}, restarting...&#34;)
            timer.cancel()
            raise
            self.start_user_update_socket(on_update)
            break</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sourse.exchange_handlers.AbstractExchangeHandler" href="#sourse.exchange_handlers.AbstractExchangeHandler">AbstractExchangeHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback" href="#sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback">KlineCallback</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.NewOrderData" href="#sourse.exchange_handlers.AbstractExchangeHandler.NewOrderData">NewOrderData</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.OrderUpdate" href="#sourse.exchange_handlers.AbstractExchangeHandler.OrderUpdate">OrderUpdate</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback" href="#sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback">PriceCallback</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.UserUpdate" href="#sourse.exchange_handlers.AbstractExchangeHandler.UserUpdate">UserUpdate</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sourse.exchange_handlers.AbstractExchangeHandler" href="#sourse.exchange_handlers.AbstractExchangeHandler">AbstractExchangeHandler</a></code></h4>
<ul class="">
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback" href="#sourse.exchange_handlers.AbstractExchangeHandler.KlineCallback">KlineCallback</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.NewOrderData" href="#sourse.exchange_handlers.AbstractExchangeHandler.NewOrderData">NewOrderData</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.OrderUpdate" href="#sourse.exchange_handlers.AbstractExchangeHandler.OrderUpdate">OrderUpdate</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback" href="#sourse.exchange_handlers.AbstractExchangeHandler.PriceCallback">PriceCallback</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.UserUpdate" href="#sourse.exchange_handlers.AbstractExchangeHandler.UserUpdate">UserUpdate</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.cancel_order" href="#sourse.exchange_handlers.AbstractExchangeHandler.cancel_order">cancel_order</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.create_order" href="#sourse.exchange_handlers.AbstractExchangeHandler.create_order">create_order</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.generate_client_order_id" href="#sourse.exchange_handlers.AbstractExchangeHandler.generate_client_order_id">generate_client_order_id</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.start_kline_socket" href="#sourse.exchange_handlers.AbstractExchangeHandler.start_kline_socket">start_kline_socket</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.start_kline_socket_threaded" href="#sourse.exchange_handlers.AbstractExchangeHandler.start_kline_socket_threaded">start_kline_socket_threaded</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.start_price_socket" href="#sourse.exchange_handlers.AbstractExchangeHandler.start_price_socket">start_price_socket</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.start_price_socket_threaded" href="#sourse.exchange_handlers.AbstractExchangeHandler.start_price_socket_threaded">start_price_socket_threaded</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.start_user_update_socket" href="#sourse.exchange_handlers.AbstractExchangeHandler.start_user_update_socket">start_user_update_socket</a></code></li>
<li><code><a title="sourse.exchange_handlers.AbstractExchangeHandler.start_user_update_socket_threaded" href="#sourse.exchange_handlers.AbstractExchangeHandler.start_user_update_socket_threaded">start_user_update_socket_threaded</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sourse.exchange_handlers.BitmexExchangeHandler" href="#sourse.exchange_handlers.BitmexExchangeHandler">BitmexExchangeHandler</a></code></h4>
<ul class="">
<li><code><a title="sourse.exchange_handlers.BitmexExchangeHandler.bitmex_signature" href="#sourse.exchange_handlers.BitmexExchangeHandler.bitmex_signature">bitmex_signature</a></code></li>
<li><code><a title="sourse.exchange_handlers.BitmexExchangeHandler.cancel_order" href="#sourse.exchange_handlers.BitmexExchangeHandler.cancel_order">cancel_order</a></code></li>
<li><code><a title="sourse.exchange_handlers.BitmexExchangeHandler.create_order" href="#sourse.exchange_handlers.BitmexExchangeHandler.create_order">create_order</a></code></li>
<li><code><a title="sourse.exchange_handlers.BitmexExchangeHandler.domen" href="#sourse.exchange_handlers.BitmexExchangeHandler.domen">domen</a></code></li>
<li><code><a title="sourse.exchange_handlers.BitmexExchangeHandler.start_kline_socket" href="#sourse.exchange_handlers.BitmexExchangeHandler.start_kline_socket">start_kline_socket</a></code></li>
<li><code><a title="sourse.exchange_handlers.BitmexExchangeHandler.start_price_socket" href="#sourse.exchange_handlers.BitmexExchangeHandler.start_price_socket">start_price_socket</a></code></li>
<li><code><a title="sourse.exchange_handlers.BitmexExchangeHandler.start_user_update_socket" href="#sourse.exchange_handlers.BitmexExchangeHandler.start_user_update_socket">start_user_update_socket</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>